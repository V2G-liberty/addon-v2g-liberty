"""Main app to manage the charging process"""

import enum
from itertools import accumulate
import math
from typing import AsyncGenerator, List, Optional
from datetime import datetime, timedelta
import isodate
from appdaemon.plugins.hass.hassapi import Hass

from .util import parse_to_int
from .notifier_util import Notifier
from .event_bus import EventBus
from .v2g_globals import time_round, he, get_local_now
from . import constants as c
from .log_wrapper import get_class_method_logger
from .chargers.base_bidirectional_evse import BidirectionalEVSE

class ChartLine(enum.Enum):
    """Used for indicating what line to write to in the chart
    1 = Normal charging schedule as generated by FM
    2 = SoC prognosis based on UI function Max Charge Now (dashed line)
    3 = SoC prognosis based on boost function when SoC is below minimum
    4, 5, 6 are the stepped price/emissions lines
    """

    SCHEDULE = 1
    MAX_CHARGE_NOW = 2
    BOOST = 3
    CONSUMPTION_PRICE = 4
    PRODUCTION_PRICE = 5
    EMISSION = 6


class V2Gliberty:
    """This class manages the bi-directional charging process.
    For this it communicates with:
    + The EVSE client, that communicates with the EV
    + The fm_client_app, that communicates with the FlexMeasures platform (which delivers the
      charging schedules).
    + Retrieves the calendar items

    This class is the primarily responsible module for providing information to the UI.
    The EVSE client does keep EVSE data up to date for presentation in the UI.
    """

    # CONSTANTS
    # Wait time before notifying the user(s) if the car is still connected during a calendar event
    MAX_EVENT_WAIT_TO_DISCONNECT: timedelta
    RESERVATION_ACTION_DISMISS:str = "dismiss"
    RESERVATION_ACTION_KEEP:str = "keep"
    EMPTY_STATES = [None, "unknown", "unavailable", ""]

    # timer_id's for reminders at start/end of the first/current event.
    timer_id_first_reservation_start: str = ""
    timer_id_event_wait_to_disconnect: str = ""
    timer_id_first_reservation_end: str = ""

    # List of targets based on the v2g_events in the reservations calendar.
    # It is a list of dicts that is populated by the method `handle_calendar_change`.
    calendar_targets: List = []

    chart_line_entity = {
        ChartLine.SCHEDULE: "soc_prognosis",
        ChartLine.MAX_CHARGE_NOW: "soc_prognosis_max_charge_now",
        ChartLine.BOOST: "soc_prognosis_boost",
        ChartLine.CONSUMPTION_PRICE: "consumption_prices",
        ChartLine.PRODUCTION_PRICE: "production_prices",
        ChartLine.EMISSION: "co2_emissions",
    }  # Price/emission lines are populated from get_fm_data module

    # Utility variables for preventing a frozen app. Call set_next_action at least every x seconds
    timer_handle_set_next_action: object = None
    call_next_action_at_least_every: int = 15 * 60
    scheduling_timer_handles: List[AsyncGenerator]

    # This is a target datetime at which the SoC that is above the max_soc must return back to or
    # below this value. It is dependent on the user setting for allowed duration above max soc.
    back_to_max_soc: datetime
    in_boost_to_reach_min_soc: bool

    # To determine if a new notification for 'unreachable target' should be sent.
    last_soonest_target_date: datetime

    # To keep track of duration of charger in error state.
    charger_in_error_since: datetime
    # initially charger_in_error_since is set to this date reference.
    # If charger_in_error_since is not equal to this date we know timing has started.
    date_reference: datetime

    # For handling no_schedule_errors
    no_schedule_errors: dict
    notification_timer_handle: object
    user_was_notified_of_no_schedule: bool
    no_schedule_notification_is_planned: bool

    quasar1_evse: BidirectionalEVSE = None
    fm_client_app: object = None
    reservations_client: object = None
    notifier: Notifier = None
    event_bus: EventBus = None
    hass: Hass = None

    def __init__(self, hass: Hass, event_bus: EventBus, notifier: Notifier):
        self.hass = hass
        self.notifier = notifier
        self.event_bus = event_bus
        self.__log = get_class_method_logger(hass.log)
        self._vehicles = []

    async def initialize(self):
        self.__log("Initializing V2Gliberty")

        # If this variable is None it means the current SoC is below the max-soc.
        self.back_to_max_soc = None

        self.MAX_EVENT_WAIT_TO_DISCONNECT = timedelta(minutes=7)

        ########## TESTDATA ############
        # self.__log(
        #     "TESTDATA! Set MAX_EVENT_WAIT_TO_DISCONNECT to 30 seconds to test timers",
        #     level="WARNING",
        # )
        # self.MAX_EVENT_WAIT_TO_DISCONNECT = timedelta(seconds=30)
        ########## TESTDATA ############

        self.in_boost_to_reach_min_soc = False
        self.timer_handle_set_next_action = ""

        # Avoid comparison with None
        self.last_soonest_target_date = get_local_now()

        # For checking how long the charger has been in error
        self.date_reference = datetime(2000, 1, 1)
        self.charger_in_error_since = self.date_reference

        # For handling no_schedule errors
        self.no_schedule_errors = {
            "invalid_schedule": False,
            "timeouts_on_schedule": False,
            "no_communication_with_fm": False,
        }

        # Reset at init
        await self.hass.turn_off("input_boolean.charger_modbus_communication_fault")
        await self.set_price_is_up_to_date(is_up_to_date=True)

        self.notification_timer_handle = None
        self.no_schedule_notification_is_planned = False

        self.fm_client_app.add_listener("no_new_schedule", self.handle_no_new_schedule)
        self.fm_client_app.add_listener(
            "unreachable_target", self.handle_unreachable_target
        )
        self.reservations_client.add_listener(
            "calendar_change", self.handle_calendar_change
        )

        await self.hass.listen_event(self.__pong, "ping")

        await self.hass.listen_state(
            self.__handle_charge_mode_change,
            "input_select.charge_mode",
            attribute="all",
        )

        # This is a disconnect request from the user through the UI.
        await self.hass.listen_event(self.__disconnect_charger, "DISCONNECT_CHARGER")

        self.event_bus.add_event_listener(
            "is_car_connected", self._update_car_connected
        )
        self.event_bus.add_event_listener(
            "charger_error_state_change", self.__handle_charger_error_state_change
        )
        self.event_bus.add_event_listener("soc_change", self.__handle_soc_change)

        self.scheduling_timer_handles = []

        # Set to initial 'empty' values, makes rendering of graph faster.
        await self.__clear_all_soc_chart_lines()
        await self.hass.run_in(self.__log_version, delay=15)
        self.__log("Completed")


    ######################################################################
    #                          PUBLIC METHODS                            #
    ######################################################################

    def add_vehicle(self, vehicle):
        """Setter: Add or replace an ElectricVehicle instance in the list."""
        # Remove existing vehicle with the same name, if any
        existing = self.get_vehicle_by_name(vehicle.name)
        if existing is not None:
            self._vehicles.remove(existing)
            self.__log(f"Replaced existing vehicle with name '{vehicle.name}'.")
        # Add the new vehicle
        else:
            self.__log(f"Added new vehicle with name '{vehicle.name}'.")

        self._vehicles.append(vehicle)

    def get_vehicle_by_name(self, name: str):
        """Getter: Retrieve an ElectricVehicle by its name."""
        for vehicle in self._vehicles:
            if vehicle.name == name:
                return vehicle
        return None

    async def kick_off_v2g_liberty(self, v2g_args=None):
        """Show the settings in the UI and kickoff set_next_action"""

        charge_mode = await self.hass.get_state("input_select.charge_mode")
        if charge_mode == "Stop":
            self.__log("Charge_mode == 'Stop' -> Setting EVSE client to inactive!")
            await self.quasar1_evse.set_inactive()
        else:
            self.__log("Charge_mode != 'Stop' -> Setting EVSE client to active!")
            await self.quasar1_evse.set_active()

        await self.hass.set_state(
            entity_id="sensor.optimisation_mode", state=c.OPTIMISATION_MODE
        )
        await self.hass.set_state(
            entity_id="sensor.utility_display_name",
            state=c.UTILITY_CONTEXT_DISPLAY_NAME,
        )
        await self.hass.set_state(
            entity_id="sensor.last_reboot_at",
            state=get_local_now().strftime(c.DATE_TIME_FORMAT),
        )

        await self.set_next_action(v2g_args=v2g_args)

    async def set_next_action(self, v2g_args=None):
        """The function determines what action should be taken next based on
        current SoC, Charge_mode, Charger_state

        This function is meant to be called upon:
        - Initialisation
        - Settings updates (from v2g_globals.py)
        - SoC updates
        - Charger state updates
        - Charge mode updates
        - Changes in the reservations calendar
        - New prices have been detected (Amber only)
        - Every 15 minutes if none of the above
        """
        # Only for debugging:
        if v2g_args is not None:
            source = v2g_args
        else:
            source = "unknown"
        self.__log(f"Set next action called from source: {source}.")

        # Make sure this function gets called every x minutes to prevent a "frozen" app.
        if self.timer_handle_set_next_action:
            self.__cancel_timer(self.timer_handle_set_next_action)
        self.timer_handle_set_next_action = await self.hass.run_in(
            self.set_next_action,
            delay=self.call_next_action_at_least_every,
        )

        if not await self.quasar1_evse.is_car_connected():
            self.__log("No car connected (or error), abort.")
            return

        ev = await self.quasar1_evse.get_connected_car()
        if ev is None:
            # Unlikely after previous check, just to be sure.
            self.__log("No connected car found, abort.")
            return
        soc = ev.soc

        charge_mode = await self.hass.get_state(
            "input_select.charge_mode", attribute="state"
        )
        self.__log(f"Setting next action based on charge_mode '{charge_mode}'.")

        # Needed in many of the cases further in this method
        now = get_local_now()

        if charge_mode == "Automatic":
            # update_charge_mode takes charger control already, not needed here.
            soc_kwh = ev.soc_kwh
            if soc_kwh in self.EMPTY_STATES:
                self.__log("SoC_kWh is 'unknown', abort.")
                return

            # If the SoC of the car is higher than the max-soc (intended for battery protection)
            # a target is set to return to the max-soc within the ALLOWED_DURATION_ABOVE_MAX_SOC
            if self.back_to_max_soc is None and soc_kwh > c.CAR_MAX_SOC_IN_KWH:
                self.back_to_max_soc = time_round(
                    (now + timedelta(hours=c.ALLOWED_DURATION_ABOVE_MAX_SOC)),
                    c.EVENT_RESOLUTION,
                )
                self.__log(
                    f"SoC above max-soc, aiming to schedule with target {c.CAR_MAX_SOC_IN_PERCENT}%"
                    f" at {self.back_to_max_soc}."
                )
            elif self.back_to_max_soc is not None and soc_kwh <= c.CAR_MAX_SOC_IN_KWH:
                self.back_to_max_soc = None
                self.__log("SoC was below max-soc, has been restored.")

            if soc < c.CAR_MIN_SOC_IN_PERCENT and not self.in_boost_to_reach_min_soc:
                # Intended for the situation where the car returns from a trip with a low battery.
                # An SoC below the minimum SoC is considered "unhealthy" for the battery,
                # this is why the battery should be charged to this minimum asap.
                # Cancel previous scheduling timers as they might have discharging instructions
                # as well.
                self.__log(
                    f"Start Boost charge: SoC '{soc}%' < minimum '{c.CAR_MIN_SOC_IN_PERCENT}%'."
                )
                self.__cancel_charging_timers()
                await self.__start_max_charge_now()
                self.in_boost_to_reach_min_soc = True

                # Create a minimal schedule to show in graph that gives user an estimation of when
                # the min. SoC will be reached. The schedule starts now with current SoC.
                boost_schedule = [dict(time=now.isoformat(), soc=soc)]

                # How much energy (wh) is needed, taking roundtrip efficiency into account
                # For % /100, for kwh to wh * 1000 results in *10...
                delta_to_min_soc_wh = (
                    (c.CAR_MIN_SOC_IN_PERCENT - soc) * c.CAR_MAX_CAPACITY_IN_KWH * 10
                ) / (c.ROUNDTRIP_EFFICIENCY_FACTOR**0.5)

                # How long will it take to charge this amount with max power, we use ceil to avoid
                # 0 minutes as this would not show in graph.
                minutes_to_reach_min_soc = int(
                    math.ceil((delta_to_min_soc_wh / c.CHARGER_MAX_CHARGE_POWER * 60))
                )
                expected_min_soc_time = now + timedelta(
                    minutes=minutes_to_reach_min_soc
                )
                boost_schedule.append(
                    dict(
                        time=expected_min_soc_time.isoformat(),
                        soc=c.CAR_MIN_SOC_IN_PERCENT,
                    )
                )

                # This also clears other soc lines
                await self.set_records_in_chart(
                    chart_line_name=ChartLine.BOOST, records=boost_schedule
                )
                message = (
                    f"Car battery state of charge ({soc}%) is too low.\n"
                    f"Charging with maximum power until minimum of ({c.CAR_MIN_SOC_IN_PERCENT}%) "
                    f"is reached.\nThis is expected around "
                    f"{expected_min_soc_time.strftime(c.DATE_TIME_FORMAT)}."
                )
                self.notifier.notify_user(
                    message=message,
                    title="Car battery is too low",
                    tag="battery_too_low",
                    critical=False,
                    send_to_all=True,
                    ttl=minutes_to_reach_min_soc * 60,
                )
                return

            if soc >= c.CAR_MIN_SOC_IN_PERCENT and self.in_boost_to_reach_min_soc:
                self.__log(
                    f"SoC above minimum ({c.CAR_MIN_SOC_IN_PERCENT}%) again while in max_boost."
                    f"Stopping max_boost."
                )
                await self.__set_charge_power(
                    {
                        "charge_power": 0,
                        "source": "set_next_action: end_of_boost_to_min_soc",
                    }
                )
                self.in_boost_to_reach_min_soc = False
                # Remove "boost schedule" from graph.
                await self.set_records_in_chart(
                    chart_line_name=ChartLine.BOOST, records=None
                )

            if soc <= (c.CAR_MIN_SOC_IN_PERCENT + 1):
                # Fail-safe, this should not happen...
                # Assume discharging to be safe
                if await self.quasar1_evse.is_discharging():
                    self.__log(
                        f"Discharging while SoC has reached minimum ({c.CAR_MIN_SOC_IN_PERCENT}%)."
                    )
                    await self.__set_charge_power(
                        {
                            "charge_power": 0,
                            "source": "set_next_action: discharge while SoC < min_soc",
                        }
                    )

            if not self.in_boost_to_reach_min_soc:
                # Not checking > max charge (97%), we could also want to discharge based on schedule
                soc_kwh = ev.soc_kwh
                schedule = None
                try:
                    schedule = await self.fm_client_app.get_new_schedule(
                        targets=self.calendar_targets,
                        current_soc_kwh=soc_kwh,
                        back_to_max_soc=self.back_to_max_soc,
                    )
                except Exception as e:
                    self.__log(f"Exception getting schedule: {e}.")
                if schedule is None:
                    self.__log("Schedule is None, not processing.")
                else:
                    self.__log(f"New schedule: {schedule}")
                    await self.__process_schedule(schedule=schedule)

        elif charge_mode == "Max boost now":
            # self.set_charger_control("take")
            # If charger_state = "not connected", the UI shows an (error) message.
            if soc >= c.CAR_MAX_CAPACITY_IN_PERCENT:
                self.__log(
                    "Reset charge_mode to 'Automatic' because max_charge is reached."
                )
                await self.__set_charge_mode_in_ui("Automatic")
            else:
                self.__log(
                    "Starting max charge now based on charge_mode = Max boost now"
                )
                await self.__start_max_charge_now()

                max_charge_now_prognoses = [dict(time=now.isoformat(), soc=soc)]

                # How much energy (wh) is needed, taking roundtrip efficiency into account
                # For % /100, for kwh to wh * 1000 results in *10...
                delta_to_max_soc_wh = (
                    (c.CAR_MAX_CAPACITY_IN_PERCENT - soc)
                    * c.CAR_MAX_CAPACITY_IN_KWH
                    * 10
                )
                delta_to_max_soc_wh = delta_to_max_soc_wh / (
                    c.ROUNDTRIP_EFFICIENCY_FACTOR**0.5
                )

                # How long will it take to charge this amount with max power, we use ceil to avoid
                # 0 minutes as this would not show in graph.
                minutes_to_reach_max_soc = int(
                    math.ceil((delta_to_max_soc_wh / c.CHARGER_MAX_CHARGE_POWER * 60))
                )
                expected_max_soc_time = (
                    now + timedelta(minutes=minutes_to_reach_max_soc)
                ).isoformat()
                max_charge_now_prognoses.append(
                    dict(time=expected_max_soc_time, soc=c.CAR_MAX_CAPACITY_IN_PERCENT)
                )
                await self.set_records_in_chart(
                    chart_line_name=ChartLine.MAX_CHARGE_NOW,
                    records=max_charge_now_prognoses,
                )

        elif charge_mode == "Max discharge now":
            if soc <= (c.CAR_MIN_SOC_IN_PERCENT + 1):
                self.__log(
                    "Minimum soc reached: set charge_mode from 'Max discharge now' to 'Automatic'."
                )
                await self.__set_charge_mode_in_ui("Automatic")
            else:
                self.__log(
                    "Starting 'Max discharge now' based on charge_mode = Max discharge now"
                )
                await self.__start_max_discharge_now()
                max_discharge_now_prognoses = [dict(time=now.isoformat(), soc=soc)]
                delta_to_min_soc_wh = (
                    (soc - c.CAR_MIN_SOC_IN_PERCENT) * c.CAR_MAX_CAPACITY_IN_KWH * 10
                )
                delta_to_min_soc_wh = delta_to_min_soc_wh / (
                    c.ROUNDTRIP_EFFICIENCY_FACTOR**0.5
                )
                minutes_to_reach_min_soc = int(
                    math.ceil(
                        (delta_to_min_soc_wh / c.CHARGER_MAX_DISCHARGE_POWER * 60)
                    )
                )
                expected_min_soc_time = (
                    now + timedelta(minutes=minutes_to_reach_min_soc)
                ).isoformat()
                max_discharge_now_prognoses.append(
                    dict(time=expected_min_soc_time, soc=c.CAR_MIN_SOC_IN_PERCENT)
                )
                await self.set_records_in_chart(
                    chart_line_name=ChartLine.MAX_CHARGE_NOW,
                    records=max_discharge_now_prognoses,
                )

        elif charge_mode == "Stop":
            # Stopping charger and giving control is done in the callback method update_charge_mode
            pass

        else:
            raise ValueError(f"Unknown option for set_next_action: {charge_mode}")

        return

    async def set_price_is_up_to_date(self, is_up_to_date: bool):
        """Helper for setting status of price data in UI"""
        if is_up_to_date:
            await self.hass.turn_off(
                "input_boolean.error_epex_prices_cannot_be_retrieved"
            )
        else:
            await self.hass.turn_on(
                "input_boolean.error_epex_prices_cannot_be_retrieved"
            )

    async def handle_calendar_change(self, v2g_events: List = None, v2g_args=None):
        """
        Draws the calendar items (v2g_events) in the UI.
        Pre_processes v2g_events to a calendar_targets list that is used for getting schedules.
        Set a timer for the start of the first reservation
        :param v2g_events: List of v2g_events (dicts)
                           All should have a start < 7-days-from-now and end > now.
        :param v2g_args: Only for logging/debugging
        :return: Nothing
        """
        self.__log(f"called with {len(v2g_events)} items from '{v2g_args}'.")
        await self.__write_events_in_ui_entity(v2g_events=v2g_events)
        await self.__draw_event_in_graph(v2g_events=v2g_events)

        is_first_reservation = True
        self.calendar_targets = []
        if v2g_events is not None and len(v2g_events) > 0:
            for car_reservation in v2g_events:
                if car_reservation == "un-initiated":
                    self.__log(
                        f"handle_calendar_change, reservation: {car_reservation}."
                        f" The reservations_client module is not initiated yet. Stop processing"
                    )
                    # The module reservations_client is not initiated yet. Stop processing
                    continue

                # Do not take dismissed car reservations into account for schedule.
                if car_reservation["dismissed"]:
                    continue

                target_start = car_reservation["start"]
                target_end = car_reservation["end"]
                # Check target_soc above max_soc and below min_soc is done in
                # the reservations_client.
                target = {
                    "start": time_round(target_start, c.EVENT_RESOLUTION),
                    "end": time_round(target_end, c.EVENT_RESOLUTION),
                    "target_soc_kwh": round(
                        float(car_reservation["target_soc_percent"])
                        / 100
                        * c.CAR_MAX_CAPACITY_IN_KWH,
                        2,
                    ),
                }
                self.calendar_targets.append(target)

                # Set a timer for the start of the first reservation
                if is_first_reservation:
                    self.__cancel_timer(self.timer_id_first_reservation_start)
                    run_at = target_start
                    now = get_local_now()
                    if target_start < now:
                        # A last minute added event, handle immediately, give some slack for
                        # processing time.
                        run_at = now + timedelta(seconds=5)
                    self.timer_id_first_reservation_start = await self.hass.run_at(
                        callback=self.__handle_first_reservation_start,
                        start=run_at,
                        v2g_event=car_reservation,
                    )
                    # Assumed is that the end will never be in the past as teh v2g_event then will
                    # not be in the list of v2g_events (any more).
                    self.__cancel_timer(self.timer_id_first_reservation_end)
                    self.timer_id_first_reservation_end = await self.hass.run_at(
                        callback=self.__handle_first_reservation_end,
                        start=target_end,
                    )
                    self.__log(
                        f"__handle_first_reservation_end planned to run at {target_end}."
                    )
                is_first_reservation = False
            # End for car_reservation loop

        await self.set_next_action(v2g_args)

    ######################################################################
    #                         PRIVATE METHODS                            #
    ######################################################################

    async def __log_version(self, kwargs):
        """
        Log version, to be called at initialisation and retried if log_version fails.
        """
        version_number = await self.hass.get_state(
            "update.v2g_liberty_update", attribute="installed_version"
        )
        if version_number is None:
            self.__log("Failed to retrieve V2G Liberty version number", level="WARNING")
            version_number = "unknown"
        res = await self.fm_client_app.log_version(version_number)
        if not res:
            # log_version failed
            attempt = kwargs.get("attempt", 0) + 1
            if attempt == 5:
                self.__log(
                    "Failed to log_version to FM after 5 attempts, aborting.", level="WARNING"
                )
                return
            await self.hass.run_in(self.__log_version, delay=15, attempt=attempt)

    async def _update_car_connected(self, is_car_connected: bool):
        self.__log(f"Acting on conneted state of car: {is_car_connected}.")
        if is_car_connected:
            await self.__handle_car_connect()
        else:
            await self.__handle_car_disconnect()

    async def __handle_car_connect(self):
        """
        Called by listener when car gets connected (the plug is inserted in the socket).
        """
        # There might be a notification to remind the user to connect,
        # if the car gets connected this notification can be removed.
        self.notifier.clear_notification(tag="reminder_to_connect")
        await self.set_next_action(v2g_args="handle_car_connect")

    async def __handle_car_disconnect(self):
        """
        Called by listener when car gets disconnected.
        Goes to this status when the plug is removed from the socket (not when disconnect is
        requested from the UI)
        """
        # Reset any possible target for discharge due to SoC > max-soc
        self.back_to_max_soc = None

        # Just to be sure, this also is done when disconnect ir requested
        self.in_boost_to_reach_min_soc = False

        # There might be a notification to ask the user to dismiss an event or not,
        # if the car gets disconnected this notification can be removed.
        self.notifier.clear_notification(tag="dismiss_event_or_not")
        self.notifier.clear_notification(tag="unreachable_target")

        # Cancel current scheduling timers
        self.__cancel_charging_timers()
        await self.__clear_all_soc_chart_lines()

        # Setting charge_mode set to automatic (was Max boost Now) as car is disconnected.
        charge_mode = await self.hass.get_state("input_select.charge_mode", None)
        if charge_mode == "Max boost now" or charge_mode == "Max discharge now":
            await self.__set_charge_mode_in_ui("Automatic")
            self.notifier.notify_user(
                message=f"Charge mode set from '{charge_mode}' to 'Automatic' as car is disconnected.",
                title=None,
                tag="charge_mode_change",
                critical=False,
                send_to_all=True,
                ttl=15 * 60,
            )

    async def handle_unreachable_target(
        self, soonest_at_target: datetime, max_target: int = None
    ):
        """Handle emitted event unreachable target (= soc at given datetime). This always only
        applies to the current or first upcoming v2g_event.

        param: soonest_at_target (datetime). Thet datetime at which the requested soc can be reached
        param: max_target: if at the end of the v2g_event the target still cannot be reached, this
               value represents the maxiumum that can be reached at the end. If None (default)the
               soc can be reached before the end of the v2g_event.

        Prevent sending several notifications. Only re-send if the soonest_at_target datetime
        changes.

        This notification does influence and is not influenced by the processes
        for 'dismiss event or not' or 'connect after event'.
        """
        if self.last_soonest_target_date == soonest_at_target:
            # Needed to avoid repeated duplicat notifications about the same issue.
            # Unfortunately HA does not filter excact duplicates automatically.
            return

        self.__log(
            f"Handle unreachable target soc soonest at target: {soonest_at_target.isoformat()}, "
            f"max possible target: {max_target}."
        )
        ve = self.calendar_targets[0]
        ve_start = ve["start"]
        ve_end = ve["end"]
        delay_in_seconds = (soonest_at_target - ve_start).total_seconds()
        time_format = "%H:%M"

        if delay_in_seconds < 420:
            self.__log(
                f"Not notifying about unreachable target as the "
                f"delay ({delay_in_seconds} sec.) is too short."
            )
            return

        half_time_ve = ve_start + (ve_end - ve_start) / 2
        # self.__log(f"Half-time-ve: {half_time_ve.strftime(time_format)}.")
        if get_local_now() > half_time_ve:
            # This can be the case if:
            # + a calendar item is added with a start-time in the past.
            # + the car is connected during a current calendar item.
            self.__log(
                "Not notifying about unreachable target as the "
                "calendar item has passed it's half-time already."
            )
            return

        self.last_soonest_target_date = soonest_at_target

        hours = int(delay_in_seconds // 3600)
        minutes = int((delay_in_seconds % 3600) // 60)
        duration = f"{hours:02}:{minutes:02}"

        if max_target is None:
            message = (
                f"The target soc of the next calendar item is expected at "
                f"{soonest_at_target.strftime(time_format)}, this is {duration} later "
                f"than planned."
            )
        else:
            message = (
                f"The target soc of the next calendar item is expected to be {max_target}%"
                f"at {ve_end.strftime(time_format)}."
            )

        ttl = round((ve_end - get_local_now()).total_seconds(), 0)
        self.__log(f"Notifying user for {ttl} sec.:\n'{message}'")
        self.notifier.notify_user(
            message=message,
            tag="unreachable_target",
            send_to_all=True,
            ttl=ttl,
        )

    async def handle_no_new_schedule(self, error_name: str, error_state: bool):
        """Keep track of situations where no new schedule is available:
        - invalid schedule
        - timeouts on schedule
        - no communication with FM
        They can occur simultaneously/overlapping, so they are accumulated in
        the dictionary self.no_schedule_errors.
        To be called from fm_client_app.
        """

        if error_name in self.no_schedule_errors:
            self.__log(
                f"handle_no_valid_schedule called with {error_name}: {error_state}."
            )
        else:
            self.__log(
                f"handle_no_valid_schedule called unknown error_name: '{error_name}'."
            )
            return
        self.no_schedule_errors[error_name] = error_state
        await self.__notify_no_new_schedule()


    async def __handle_charger_error_state_change(
        self, persistent_error: bool, was_car_connected: bool
    ):
        if persistent_error:
            await self._persistent_charger_error(was_car_connected)
        else:
            await self._persistent_charger_error_solved()

    async def _persistent_charger_error(self, was_car_connected: bool):
        """Handle a none-responsive charger:
        - Stop charging
        - Set message in UI
        - Notify admin with (critical) message
        To be called from evse_client_app when the charger is considered none-responsive.
        :param was_car_connected: Was the car connected at the moment the charger became
                                  none-responsive. Determines if the notification needs to
                                  be critical or not.
        :returns: Noting
        """
        self.__log(
            "The charger probably crashed: Stop charging, set Error in UI and notify user"
        )
        await self.__set_charge_mode_in_ui("Stop")

        await self.hass.set_state(
            "input_boolean.charger_modbus_communication_fault", state="on"
        )
        await self.hass.set_state(entity_id="sensor.charger_state_text", state="Error")

        title = "Charger communication error"
        message = (
            "Automatic charging has been stopped!\n"
            "Please click this notification to open the V2G Liberty App "
            "and follow the steps to solve this problem."
        )
        # Do not send a critical warning if car was not connected.
        critical = was_car_connected
        self.notifier.notify_user(
            message=message,
            title=title,
            tag="charger_modbus_crashed",
            critical=critical,
            send_to_all=False,
        )
        return

    async def _persistent_charger_error_solved(self):
        """To clear UI alert and notification if it is still present."""
        self.__log("Called")
        await self.hass.set_state(
            "input_boolean.charger_modbus_communication_fault", state="off"
        )
        identification = {
            "recipient": c.ADMIN_MOBILE_NAME,
            "tag": "charger_modbus_crashed",
        }
        self.notifier.clear_notification(identification)

    async def set_records_in_chart(self, chart_line_name: ChartLine, records: dict):
        """Write or remove records in lines in the chart.

        If records = None the line_name line will be cleared (made invisible),
        e.g. when the car gets disconnected and the SoC prognosis boost is not relevant (any more)

        Parameters:
            chart_line_name (ChartLine): indicating which line to write to
            records(dict): a dictionary of time (isoformat) + value (e.g. cent/kWh or %) records

        For the SoC related lines (prognoses, boost, max_charge_now): if there is data in records,
        it is assumed that the other lines need to be erased.

        Returns:
            Nothing
        """
        now = get_local_now()

        # There seems to be no way to hide the SoC series from the graph,
        # so it is filled with "empty" data, one record of None.
        # Set it at a week from now, so it's not visible in the default view.
        clear_line_records = dict(
            records=[dict(time=(now + timedelta(days=7)).isoformat(), soc=None)]
        )

        # To make sure the new attributes are treated as new we set a new state as well
        new_state = "Chart line data at " + now.isoformat()
        entity = f"sensor.{self.chart_line_entity[chart_line_name]}"

        if records is None:
            await self.hass.set_state(
                entity, state=new_state, attributes=clear_line_records
            )
            self.__log(f"chart_line_name '{chart_line_name}' cleared.")
        else:
            result = {"records": records}
            await self.hass.set_state(entity, state=new_state, attributes=result)
            self.__log(
                f"entity: '{entity}', "
                f"attributes: {str(result)[:50]} ... {str(result)[-25:]}."
            )

            # If a soc line is set, clear the others
            soc_lines = [ChartLine.SCHEDULE, ChartLine.BOOST, ChartLine.MAX_CHARGE_NOW]
            if chart_line_name in soc_lines:
                self.__log(
                    f"chart_line_name '{chart_line_name}' in soc_lines, clear others."
                )
                for chart_line in soc_lines:
                    if chart_line == chart_line_name:
                        continue
                    entity = f"sensor.{self.chart_line_entity[chart_line]}"
                    await self.hass.set_state(
                        entity, state=new_state, attributes=clear_line_records
                    )
                    self.__log(f"chart_line_name '{chart_line}' cleared.")

    ######################################################################
    #                    PRIVATE CALLBACK FUNCTIONS                      #
    ######################################################################

    async def __pong(self, event, data, kwargs):
        self.hass.fire_event("ping.result")

    async def __handle_charge_mode_change(self, entity, attribute, old, new, kwargs):
        """Handle changes in the charge mode
        Here only the change from one to another mode is handled.
        Set_next_action regularly checks what to do based on the current state (=the new state here)
        """
        new_state = new.get("state", None)
        old_state = old.get("state", None)
        self.__log(f"Charge mode has changed from '{old_state}' to '{new_state}'")

        await self.__clear_all_soc_chart_lines()

        if old_state == "Automatic":
            self.__log("Cancel scheduled charging (timers).")
            self.__cancel_charging_timers()
            await self.__reset_no_new_schedule()

        if (
            old_state in ["Max boost now", "Max discharge now"]
            and new_state == "Automatic"
        ):
            # When mode goes from "Max boost now" to "Automatic" charging needs to be stopped.
            # Let schedule (later) decide if starting is needed
            await self.__set_charge_power(
                {
                    "charge_power": 0,
                    "source": "Reset for 'Max boost now' to 'Automatic'",
                }
            )

        if old_state != "Stop" and new_state == "Stop":
            # New mode "Stop" is handled by set_next_action
            self.__log(
                "Stop charging (if in action) and give control based on charge_mode = Stop"
            )
            self.in_boost_to_reach_min_soc = False
            await self.quasar1_evse.set_inactive()
            # For monitoring
            await self.hass.set_state(
                "sensor.current_scheduled_charging_power",
                state="unavailable",
            )

        if old_state == "Stop" and new_state != "Stop":
            await self.quasar1_evse.set_active()

        await self.set_next_action(v2g_args="__handle_charge_mode_change")
        return

    async def __handle_soc_change(self, new_soc: int, old_soc: int):
        """Function to handle updates in the car SoC"""
        self.__log(f"new_soc: {new_soc}%, old_soc: {old_soc}%.")
        await self.set_next_action(v2g_args="__handle_soc_change")

        if (
            await self.quasar1_evse.is_charging()
            and new_soc == c.CAR_MAX_SOC_IN_PERCENT
        ):
            ev = await self.quasar1_evse.get_connected_car()
            if ev is None:
                self.__log("No connected car found, abort.")
                return
            message = (
                f"Car battery at {new_soc} %, "
                f"range ≈ {ev.remaining_range_km} km."
            )
            self.__log(f"{message=}")
            self.notifier.notify_user(
                message=message,
                tag="battery_max_soc_reached",
                send_to_all=True,
                ttl=60 * 15,
            )

    async def __disconnect_charger(self, *args, **kwargs):
        """Function to make it possible for the user to disconnect the charger.
        Reacts to button in UI that fires DISCONNECT_CHARGER event.
        """
        self.__log("charger disconnect requested")
        await self.__reset_no_new_schedule()

        # When disconnection during boost_to_reach_min_soc this needsa to be reset to allow
        # reactivating this mode when car does not get disconnected.
        # This also is set when car is actually disconnected
        self.in_boost_to_reach_min_soc = False

        await self.quasar1_evse.stop_charging()
        # Control is not given to user, this is only relevant if charge_mode is "Off" (stop).
        self.notifier.notify_user(
            message="Charger is disconnected",
            tag="charger_disconnected",
            send_to_all=True,
            ttl=5 * 60,
        )

    ######################################################################
    #               PRIVATE UTILITY METHODS                              #
    ######################################################################

    async def __clear_all_soc_chart_lines(self):
        await self.set_records_in_chart(
            chart_line_name=ChartLine.SCHEDULE, records=None
        )
        await self.set_records_in_chart(chart_line_name=ChartLine.BOOST, records=None)
        await self.set_records_in_chart(
            chart_line_name=ChartLine.MAX_CHARGE_NOW, records=None
        )

    ######################################################################
    #                PRIVATE FUNCTIONS FOR NO-NEW-SCHEDULE               #
    ######################################################################

    async def __reset_no_new_schedule(self):
        """Sets all errors to False and removes notification / UI messages
        To be used when:
        - The car gets disconnected, so that while it stays in this state there is no
        unneeded "alarming" message/notification.
        - Chargemode is no longer "Automatic": then no schedules are fetched.
        """

        for error_name in self.no_schedule_errors:
            self.no_schedule_errors[error_name] = False
        await self.__notify_no_new_schedule(reset=True)

    async def __notify_no_new_schedule(self, reset: Optional[bool] = False):
        """Check if notification of user about no new schedule available is needed,
        based on self.no_schedule_errors. The administration for the errors is done by
        handle_no_new_schedule().

        When error_state = True of any of the errors:
            Set immediately in UI
            Notify once if remains for an hour
        When error state = False:
            If all errors are solved:
                Remove from UI immediately
                If notification has been sent:
                    Notify user the situation has been restored.

        :param reset: bool, optional
                Reset is meant for the situation where the car gets disconnected and all
                notifications can be cancelled and messages in UI removed.
                Then also no "problems are solved" notification is sent.
        """

        if reset:
            if self.hass.timer_running(self.notification_timer_handle):
                res = await self.hass.cancel_timer(self.notification_timer_handle)
                self.__log(
                    f"__notify_no_new_schedule, notification timer cancelled: {res}."
                )
            self.no_schedule_notification_is_planned = False
            self.notifier.clear_notification(tag="no_new_schedule")
            await self.hass.set_state(
                "input_boolean.error_no_new_schedule_available", state="off"
            )
            return

        any_errors = False
        for error_name in self.no_schedule_errors:
            if self.no_schedule_errors[error_name]:
                any_errors = True
                break

        if any_errors:
            await self.hass.set_state(
                "input_boolean.error_no_new_schedule_available", state="on"
            )
            if not self.no_schedule_notification_is_planned:
                # Plan a notification in case the error situation remains for more than an hour
                self.notification_timer_handle = await self.hass.run_in(
                    self.__no_new_schedule_notification, delay=60 * 60
                )
                self.no_schedule_notification_is_planned = True
        else:
            await self.hass.set_state(
                "input_boolean.error_no_new_schedule_available", state="off"
            )
            canceled_before_run = await self.hass.cancel_timer(
                self.notification_timer_handle, True
            )
            self.__log(
                f"notification timer cancelled before run: {canceled_before_run}."
            )
            if self.no_schedule_notification_is_planned and not canceled_before_run:
                # Only send this message if "no_schedule_notification" was actually sent
                title = "Schedules available again"
                message = (
                    "The problems with schedules have been solved.\n"
                    "If you've set charging via the chargers app, "
                    "consider to end that and use automatic charging again."
                )
                self.notifier.notify_user(
                    message=message,
                    title=title,
                    tag="no_new_schedule",
                    critical=False,
                    send_to_all=True,
                    ttl=30 * 60,
                )
            self.no_schedule_notification_is_planned = False

    def __no_new_schedule_notification(self, v2g_args=None):
        # Work-around to have this in a separate function (without arguments) and not inline in
        # handle_no_new_schedule. This is needed because self.hass.run_in() with kwargs does not
        # really work well and results in this app crashing.
        title = "No new schedule available"
        message = (
            "If available, the current schedule will remain active.\nUsually this problem is solved"
            " automatically in an hour or so.\nIf the schedule does not fit your needs, consider "
            "charging manually via the chargers app."
        )
        self.notifier.notify_user(
            message=message,
            title=title,
            tag="no_new_schedule",
            critical=False,
            send_to_all=True,
        )
        self.__log("Notification 'No new schedule' sent.")

    ######################################################################
    #                PRIVATE FUNCTIONS FOR TIMERS                        #
    ######################################################################

    def __cancel_timer(self, timer_id: str):
        """Utility function to silently cancel a timer.
        Born because the "silent" flag in cancel_timer does not work and the
        logs get flooded with useless warnings.

        Args:
            timer_id: timer_handle to cancel
        """
        if self.hass.timer_running(timer_id):
            silent = True  # Does not really work
            self.hass.cancel_timer(timer_id, silent)

    def __cancel_charging_timers(self):
        for h in self.scheduling_timer_handles:
            self.__cancel_timer(h)
        self.scheduling_timer_handles = []
        self.__log(
            f"Canceled all {len(self.scheduling_timer_handles)} charging timers."
        )

    def __reset_charging_timers(self, handles):
        self.__log(
            f"__reset_charging_timers: cancel current and set {len(handles)} new charging timers."
        )
        # We need to be sure no new timers are added unless the old are removed
        self.__cancel_charging_timers()
        self.scheduling_timer_handles = handles
        # self.__log("finished __reset_charging_timers")

    ######################################################################
    # PRIVATE FUNCTIONS FOR COMPOSING, GETTING AND PROCESSING SCHEDULES  #
    ######################################################################

    async def __process_schedule(self, schedule: dict):
        """Process a schedule by setting timers to start charging the car.

        If appropriate, also starts a charge directly.
        Finally, the expected SoC (given the schedule) is calculated and saved to
        sensor.soc_prognosis.
        """

        if await self.hass.get_state("input_select.charge_mode", None) != "Automatic":
            # This situation can occure when chargemode changed (quicky) during past moments
            # (seconds) from Automatic (triggering a schedule to be fetched and this process is not
            # stopped by switching to an other charge_mode) to any other charge mode.
            self.__log("aborted: charge_mode is not automatic (any more).")
            return

        if not await self.quasar1_evse.is_car_connected():
            self.__log("aborted: car is not connected")
            return

        ev = await self.quasar1_evse.get_connected_car()
        if ev is None:
            self.__log("aborted: no connected car found.")
            return
        if ev.soc in self.EMPTY_STATES:
            self.__log("aborted: soc is 'unknown'")
            return

        if schedule is None:
            self.__log("aborted: no schedule found.")
            return

        values = schedule.get("values", None)
        if values is None:
            self.__log("aborted: no values found.")
            return

        duration = schedule.get("duration", None)
        if duration is None:
            self.__log("aborted: no duration found.")
            return

        start = schedule.get("start", None)
        if start is None:
            self.__log("aborted: no start datetime found.")
            return

        duration = isodate.parse_duration(duration)
        resolution = duration / len(values)
        start = isodate.parse_datetime(start)

        # Check against expected control signal resolution
        if resolution < c.EVENT_RESOLUTION:
            self.__log(
                f"aborted: the resolution ({resolution}) is below "
                f"the set minimum ({c.EVENT_RESOLUTION})."
            )
            await self.handle_no_new_schedule("invalid_schedule", True)
            return

        # Detect invalid schedules
        # If a fallback schedule is sent assume that the schedule is invalid if all values
        # (usually 0) are the same.
        is_fallback = (
            schedule["scheduler_info"]["scheduler"] == "StorageFallbackScheduler"
        )
        if is_fallback and (all(val == values[0] for val in values)):
            self.__log(
                f"Invalid fallback schedule, all values are the same: {values[0]}. Aborting."
            )
            await self.handle_no_new_schedule("invalid_schedule", True)
            # Skip processing this schedule to keep the previous
            return
        else:
            await self.handle_no_new_schedule("invalid_schedule", False)

        self.__log("valid schedule")

        # Create new scheduling timers, to send a control signal for each value
        handles = []
        now = get_local_now()
        # To be able to differentiate between different schedules the time is added.
        str_source = f"schedule@{now.strftime('%H:%M:%S')}"
        timer_datetimes = [start + i * resolution for i in range(len(values))]
        # convert from MegaWatt from schedule to Watt for charger
        mw_to_w_factor = 1000000

        for t, value in zip(timer_datetimes, values):
            if t > now:
                # AJO 17-10-2021
                # ToDo: If value is the same as previous, combine them so we have less timers and
                # switching moments?
                h = await self.hass.run_at(
                    self.__set_charge_power,
                    t,
                    charge_power=int(value * mw_to_w_factor),
                    source=str_source,
                )
                handles.append(h)
            else:
                await self.__set_charge_power(
                    {
                        "charge_power": int(value * mw_to_w_factor),
                        "source": str_source,
                    }
                )
        self.__reset_charging_timers(handles)  # This also cancels previous timers

        exp_soc_values = list(
            accumulate(
                [ev.soc]
                + convert_MW_to_percentage_points(
                    values,
                    resolution,
                    c.CAR_MAX_CAPACITY_IN_KWH,
                    c.ROUNDTRIP_EFFICIENCY_FACTOR,
                )
            )
        )

        exp_soc_datetimes = [start + i * resolution for i in range(len(exp_soc_values))]
        expected_soc_based_on_scheduled_charges = [
            dict(time=t.isoformat(), soc=round(v, 2))
            for v, t in zip(exp_soc_values, exp_soc_datetimes)
        ]
        await self.set_records_in_chart(
            chart_line_name=ChartLine.SCHEDULE,
            records=expected_soc_based_on_scheduled_charges,
        )

    async def __set_charge_power(self, kwargs: dict):
        """Wrapper function for start_charge_with_power on the modbus_evse module.
        Also writes to the current_scheduled_charging_power sensor.

        Args:
            Kwargs is used to be able to call this function with "run_at"
            kwargs (dict): a dict containing
             - charge_power(int) in Watt
             - source(str) for debugging
        """
        charge_power = kwargs.get("charge_power", None)
        charge_power_in_watt = parse_to_int(charge_power, None)
        if charge_power_in_watt is None:
            self.__log("invalid charge_power: None")
            return

        source = kwargs.get("source", "unknown source")

        await self.quasar1_evse.start_charging(
            power_in_watt=charge_power_in_watt,
            source=source,
        )
        # For monitoring
        await self.hass.set_state(
            "sensor.current_scheduled_charging_power",
            state=charge_power,
        )

    async def __start_max_discharge_now(self):
        # TODO: Check if .set_active() is really a good idea here?
        #       If the client is not active there might be a good reason for that...
        await self.quasar1_evse.set_active()
        await self.__set_charge_power(
            {
                "charge_power": -c.CHARGER_MAX_DISCHARGE_POWER,
                "source": "__start_max_discharge_now",
            }
        )

    async def __start_max_charge_now(self):
        # TODO: Check if .set_active() is really a good idea here?
        #       If the client is not active there might be a good reason for that...
        await self.quasar1_evse.set_active()
        await self.__set_charge_power(
            {
                "charge_power": c.CHARGER_MAX_CHARGE_POWER,
                "source": "__start_max_charge_now",
            }
        )

    ######################################################################
    #              PRIVATE METHODS FOR CALENDAR RESERVATIONS             #
    ######################################################################

    async def __handle_first_reservation_start(self, v2g_event):
        """
        To be run at the start of the first reservation (or a.s.a.p. if a reservation has already
        started).
        Schedule a notification when the v2g_event has started but car is still connected

        :param v2g_event: v2g calendar item
        """
        v2g_event = v2g_event["v2g_event"]

        # As the calendar has changed we assume the first event has changed. So, the current timer
        # needs to be cancelled and possibly replaced by a new one.
        self.__cancel_timer(self.timer_id_event_wait_to_disconnect)
        run_at = get_local_now() + self.MAX_EVENT_WAIT_TO_DISCONNECT
        if run_at > v2g_event["end"]:
            # This is rare but can be the case if a calendar item is added whereby the start is in
            # the past and the end is in the future.
            return

        # Set a timer for MAX_EVENT_WAIT_TO_DISCONNECT in minutes after the start of
        # the reservation to check if car is still connected.
        # If still connected, ask user via notification if the item can be dismissed.
        self.timer_id_event_wait_to_disconnect = await self.hass.run_at(
            callback=self.__ask_user_dismiss_event_or_not,
            start=run_at,
            v2g_event=v2g_event,
        )
        self.__log(f"__ask_user_dismiss_event_or_not is set to run at {run_at.isoformat}.")

    async def __handle_first_reservation_end(self, v2g_args: str = ""):
        # To prevent the call to __remind_user_to_connect_after_event() being cancelled due to
        # calendar changes,whereby the events in the past would be discarded, we here do not build
        # in the cancellation.

        # The connected state is checked here and in at __remind_user_to_connect_after_event to make
        # sure the notification is only sent when the car was disconnected  for a longer period.
        self.__log(
            f"__handle_first_reservation_end called with v2g_args = '{v2g_args}'."
        )
        if not await self.quasar1_evse.is_car_connected():
            run_at = get_local_now() + self.MAX_EVENT_WAIT_TO_DISCONNECT
            self.__log(
                f"setting __remind_user_to_connect_after_event at {run_at.isoformat()}"
            )
            await self.hass.run_at(
                callback=self.__remind_user_to_connect_after_event,
                start=run_at,
                v2g_args=f"after {self.MAX_EVENT_WAIT_TO_DISCONNECT}s event-start car still not connected",
            )

    async def __ask_user_dismiss_event_or_not(self, v2g_event: dict):
        self.__log(
            f"called with v2g_event: {v2g_event}."
        )

        v2g_event = v2g_event["v2g_event"]
        if await self.quasar1_evse.is_car_connected():
            identification = " ".join(
                filter(None, [v2g_event["summary"], v2g_event["description"]])
            )
            if len(identification) > 25:
                identification = identification[0:25] + "…"
            self.__log(
                f"event_title: {identification}."
            )
            # Will be cancelled when car gets disconnected.
            hid = v2g_event["hash_id"]
            message = (
                f"The car is still connected while it was reserved to leave: '{identification}'.\n"
                f"What would you like to do?"
            )
            user_actions = [
                {
                    "action": f"{self.RESERVATION_ACTION_DISMISS}+{hid}",
                    "title": "Dismiss reservation",
                },
                {"action": f"{self.RESERVATION_ACTION_KEEP}+{hid}", "title": "Keep reservation"},
            ]
            self.notifier.notify_user(
                message=message,
                title="Keep reservation for scheduling?",
                tag="dismiss_event_or_not",
                send_to_all=True,
                actions=user_actions,
                callback=self._cb_ask_user__dismiss_event_or_not,
            )
        else:
            self.__log(
                f"__ask_user_dismiss_event_or_not, unexpected call for event with "
                f"hash_id {v2g_event['hash_id']} as car is already disconnected."
            )

    async def _cb_ask_user__dismiss_event_or_not(self, user_action):
        self.__log(f"user_action: '{user_action}'.")
        self.notifier.clear_notification(tag="dismiss_event_or_not")

        # User reacted to question to keep or dismiss a reservation.
        # The notification can be removed for other users.
        action_parts = str(user_action).split("+")
        reservation_action = action_parts[0]
        hid = action_parts[1]
        if reservation_action == self.RESERVATION_ACTION_DISMISS:
            dismiss = True
        elif reservation_action == self.RESERVATION_ACTION_KEEP:
            dismiss = False
        else:
            self.__log(f"aborting: unknown action: '{reservation_action}'.")
            return

        await self.reservations_client.set_event_dismissed_status(event_hash_id=hid, status=dismiss)

    async def __remind_user_to_connect_after_event(self, v2g_args: str = ""):
        # Only to be called from __handle_first_reservation_end().
        # If the car is not connected a little after a reservations ends we remind the users to
        # connect it as it is assumed they forgot to do so.
        self.__log(f"__remind_user_to_connect_after_event, called {v2g_args=}.")
        if not await self.quasar1_evse.is_car_connected():
            self.__log(
                "__remind_user_to_connect_after_event, car not connected, notifying users."
            )
            self.notifier.notify_user(
                message="The car is not connected while it was expected to have returned after a reservation. ",
                tag="reminder_to_connect",
                send_to_all=True,
            )

    async def __write_events_in_ui_entity(self, v2g_events: List = None):
        # Prepare for rendering in the UI
        start = get_local_now()
        v2g_ui_event_calendar = []
        for n in range(7):
            calendar_date = start + timedelta(days=n)
            events_in_day = []
            for v2g_ui_event in v2g_events:
                if v2g_ui_event["start"].date() == calendar_date.date():
                    # HTML Escape text before writing to UI
                    v2g_ui_event["summary"] = he(v2g_ui_event["summary"])
                    v2g_ui_event["description"] = he(v2g_ui_event["description"])
                    events_in_day.append(v2g_ui_event)
            if len(events_in_day) > 0:
                day = {"day": calendar_date, "events": events_in_day}
                v2g_ui_event_calendar.append(day)
        attributes = {"v2g_ui_event_calendar": v2g_ui_event_calendar}
        await self.hass.set_state(
            "sensor.calendar_events", state=start, attributes=attributes
        )

    async def __draw_event_in_graph(self, v2g_events: List = None):
        now = get_local_now()
        if len(v2g_events) == 0:
            # There seems to be no way to hide the SoC series from the graph,
            # so it is filled with "empty" data, one record of 0.
            # Set it at a week from now, so it's not visible in the default view.
            ci_chart_items = [
                dict(time=(now + timedelta(days=7)).isoformat(), soc=None)
            ]
        else:
            ci_chart_items = []

            for ci in v2g_events:
                # If ci is dismissed, do not draw
                status = ci.get("dismissed", None)
                if status is not None and status == True:
                    continue

                # Add to create a gap between ci's in the graph.
                ci_chart_items.append({"time": ci["start"].isoformat(), "soc": 0})
                ci_chart_items.append(
                    {"time": ci["start"].isoformat(), "soc": ci["target_soc_percent"]}
                )
                ci_chart_items.append(
                    {"time": ci["end"].isoformat(), "soc": ci["target_soc_percent"]}
                )
                # Add to create a gap between ci's in the graph.
                ci_chart_items.append({"time": ci["end"].isoformat(), "soc": 0})

        # To make sure the new attributes are treated as new we set a new state as well
        new_state = f"Calendar item available at {now.isoformat()}."
        result = dict(records=ci_chart_items)
        await self.hass.set_state(
            "sensor.calender_item_in_chart", state=new_state, attributes=result
        )

    async def __set_charge_mode_in_ui(self, setting: str):
        """Set the charge mode in the UI. By setting the UI switch an
        event will also be fired. So other code will run due to this setting.

        Parameters:
        setting (str): Automatic, MaxBoostNow or Stop (=Off)
        """

        if setting == "Automatic":
            # Used when car gets disconnected and ChargeMode was MaxBoostNow.
            await self.hass.turn_on("input_boolean.chargemodeautomatic")
        elif setting == "MaxBoostNow":
            # Not used for now, just here for completeness. The situation with SoC below the set
            # minimum is handled without setting the UI to MaxBoostNow
            await self.hass.turn_on("input_boolean.chargemodemaxboostnow")
        elif setting == "Stop":
            # Used when charger crashes to stop further processing
            await self.hass.turn_on("input_boolean.chargemodeoff")
        else:
            self.__log(f"Invalid charge_mode in UI setting: '{setting}'.", level="WARNING")


######################################################################
#                    PRIVATE UTILITY FUNCTIONS                       #
######################################################################


def convert_MW_to_percentage_points(
    values_in_MW,
    resolution: timedelta,
    max_soc_in_kWh: float,
    round_trip_efficiency: float,
):
    """
    For example, if a 62 kWh battery produces at 0.00575 MW for a period of 15 minutes,
    its SoC increases by just over 2.3%.
    """
    e = round_trip_efficiency**0.5
    scalar = resolution / timedelta(hours=1) * 1000 * 100 / max_soc_in_kWh
    lst = []
    for v in values_in_MW:
        if v >= 0:
            lst.append(v * scalar * e)
        else:
            lst.append(v * scalar / e)
    return lst
